## 泛型

#### 泛型的简单使用

> 泛型就相当于是一个变量

```js
// 使用T来约束类型, 后面传入的什么, 类型就是什么, 如果传入number, 则返回的是以number构成的数组
// T不是固定写法，一般使用T;
const getArray = <T>(value: T, times: number = 5): T[] => {
    return new Array(times).fill(value)
}
// 调用之前指定类型
// 如果传入string, 则会报错, string是没有length的;
getArray<number>(123, 4).map(item => item.length)
```

#### 多个泛型时

```js
const getArray = <T, U>(value: T, params: U, times: number): Array<[T, U]> => {
    return new Array(times).fill([value, param2])
}
// 也可以不指定类型, 会根据值自动确定类型;
getArray(1,'a',3).forEach(item => {
    console.log(item[0].length) // 报错, 数字类型没有length属性
})
```

#### 接口使用泛型变量

```js
// 第一种
interface getArr {
    <T>(arg1: T, times: number): T[]
}

// 第二种
interface getArr<T> {  // 使用这种形式, 里面定义的都可以使用该变量了
    (arg1: T, times: number): T[],
    array: T[] // 以t构成的数组;
}
```

#### 泛型约束

1. 使用extends来约束类型，下面的例子表示传入的参数需要有length属性；

```js
interface ValueWithLength {
    length: number
}
const getArr = <T extends ValueWithLength>(arg1: T, times): T[] => {
    return new Array(times).fill(arg)
}
getArr(123) // 报错
```

2. 泛型约束限制值是对象里面的一员

```js
let obj = {
    a: 'a',
    b: 'b'
}
// extends keyof表示继承T,相当于obj返回的键名组成的数组, k就是其中的一员
const getProps = <T, K extends keyof T>(object: T, propName: K) => {
    return object[propName]
}
getProps(obj, 'a')
getProps(obj, 'c') // 报错, (如果不进行keyof约束, 则不会报错, 返回undefined)
```

