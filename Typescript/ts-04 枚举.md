# TS-04 枚举

## 枚举

> 常用枚举场景：定义接口返回的code码，对应枚举属性，提高代码的可读性

### 索引枚举

```ts
const test = 2
const getIndex = ():number => {
    return 2
}
enum Status {
    Uploading = test,
    Success = getIndex(),
    Faild = 2 // 不指定则报错
}
```

默认值为0开始，也可以指定初始值，初始值也可以设置为常量，也可以是函数计算，当是函数计算时，后面的值就不能够再递增了，需要给定默认值；



### 字符串枚举

```ts
enum Message {
    Error: 'sorry error',
    Success: 'success',
    Fail = Error // 也可以直接使用成员,
}
console.log(Message.Error)
```

字符串枚举只能使用自己枚举下面的成员，不能使用其他枚举中的成员；



### 异构枚举

> 既有索引又有字符串的称为异构枚举

```ts
enum Result {
    Faild = 0,
    Success = 'success'
}
```

如果不是特别需要，不建议使用异构枚举；



### 枚举成员类型和联合枚举类型

> 当一个枚举类型满足一定的条件的时候，那么枚举的每个成员，以及枚举其本身都可以作为类型来使用

满足的条件：

* 不带初始值的成功：enum E { A }
* 值为字符串字面量：enum E { A = 'a' }
* 值为数值字面量或者带有负值正值都行：enum E { A = -2 }

#### 枚举类型

```ts
enum Anima {
    Dog = 1,
    Cat = 2
}
interface Dog {
    type: Anima.Dog,
}
const dog: Dog = {
    type: Anima.Dog
}
```

#### 联合枚举类型

> 如number | string就是联合枚举类型

```ts
enum Status {
    Off,
    On
}
interface Light {
    status: Status
}
const light: Light {
    status: Status.Off
}
```



### const枚举

> 在枚举前面添加const，定义该枚举被编译后值为常量，不再为对象里面取值了，其他成员也都会在编译时被删除

枚举值编译完之后就是一个真实的对象，当使用const定义枚举之后编译的就直接是常量了；

```ts
const enum Status {
    Success = 200
}
const S = Status.Success
// 编译之后直接是var s = 200
```



### 外部枚举

外部枚举使用`declare enum`定义的枚举类型

```ts
declare enum Directions {
    Up,
    Down,
    Left,
    Right
}

```

declare定义的类型只会用于编译检查，编译结果中会被删除；

> ts的枚举类型的概念来源C#

