# 声明文件

**为什么需要声明文件**

当引入了全局的库之后，比如`jQuery`库，会在`ts`文件中使用`$`符，在`ts`文件中直接使用是会提示找不到文件的，是因为没有声明文件；

**声明文件的查找**

可以在`tsconfig.json`文件中，添加`include`字段，配置声明文件的路径，如果不配置，则会查找所有文件夹下面的`.d.ts`文件；

```json
{
    "include": [
        "./scr/**/*.ts", // 代表src下面某个文件夹下面的声明文件
        "./src/**/*.d.ts"
    ]
}
```

声明文件使用`declare`关键字来声明文件；

**查看声明文件**

在`ts`中，大多数库都被社区编写了声明文件，在`node_modules`找到安装的库，之后查看`*.d.ts`文件，里面就是写好的声明文件，如果没有，则需要手动安装，安装时加上`@types/*`即可，如果安装成功了，说明有这个库的声明文件，如果找不到安装的模块，则需要手动编写声明文件；



## 全局库

如何判断是否是全局可以使用的变量：

官方声明文件的例子：[官方模块](https://www.tslang.cn/docs/handbook/declaration-files/templates.html)，可以参考`global.d.ts`文件的例子；

通过定义`document`或者`window`上面添加方法时，都是全局可以使用的变量

```ts
// 如果添加了一个全局的getTitle方法，并且返回的是string, 当声明了之后则可以使用了;
declare function getTitle(): string
```

当修改了声明文件时，需要重新编译，否则报错；



## 模块化库

使用`import`语句或者`require`语句的，一般都是模块化库

可以参数官方的`module-*.d.ts`的模板；



## UMD库

一般有以下两种判断的都是`UMD`库

```ts
// 判断define
typeof define === 'function' // 只要是不等于undefined

//判断module
typeof module === 'object' && module.exports
```

很多库都是`UMD`库，比如`jquery`、`moment`





## 修改全局模块编写声明文件

当我们在`String`、`Array`等原型上面添加了方法时，如何填写声明文件

```ts
String.prototype.getFirstLetter = function(){
    return this[0]
}

// global.d.ts 写声明文件
// 利用声明合并
interface String {
    getFirstLetter(): string
}
```



 ## 使用依赖

库多数会依赖其他的库，比如`nodejs`，

使用`reference`指定`types`来引入该模块

比如某个库依赖了`moment`：

```ts
/// <reference types='moment'/>
// or
import * as moment from 'moment'
```

如果全局库依赖的是某个`UMD`模块，也可以使用`reference`来指定某个`UMD`模块的依赖



**注意：** 

1. 防止命名冲突，因为都是在全局填写的，很容易产生冲突，建议将相关的东西放在命名空间里面，使用对象的形式去访问，防止命名污染
2. `ES6`模块的插件影响，一些开发者为一些库开发了插件，用于在之前的库中添加更多的功能，这往往是需要修改原有的库导出的模块的，es6模块中导出的模块是不能修改的，但是在commonjs和一些加载器是允许的；



## 快捷外部模块声明

如果使用一个新模块，不想花时间精力为该模块填写声明，只需要在`typing`文件夹下面创建文件夹编写即可，比如`moment`：

```ts
// typings/moment/index.d.ts
declare module 'moment' //快速导出模块
```



